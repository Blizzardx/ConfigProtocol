package exportTool

import (
	"github.com/Blizzardx/ConfigProtocol/common"
	"github.com/Blizzardx/ConfigProtocol/define"
)

const codeTemplate_CsharpMap = `// Generated by gen-tool
// DO NOT EDIT!
using System.Collections.Generic;
using System;
using ConfigProto.core;

namespace {{.PackageName}}
{
{{.EnumInfoTemplate}}

    public class {{.ConfigName}}
    {
        public Dictionary<{{.MapKeyType}}, {{.ConfigName}}Info> Content;
    }
    public class {{.ConfigName}}Info
    {
{{range .FieldList}}	 
        public {{.Type}} {{.Name}};
{{end}}
    }
}

`
const codeTemplate_CsharpList = `// Generated by gen-tool
// DO NOT EDIT!
using System.Collections.Generic;
using System;
using ConfigProto.core;

namespace {{.PackageName}}
{
{{.EnumInfoTemplate}}

    public class {{.ConfigName}}
    {
        public List<{{.ConfigName}}Info> Content;
    }
    public class {{.ConfigName}}Info
    {
{{range .FieldList}}	 
        public {{.Type}} {{.Name}};
{{end}}
    }
}

`
const codeTemplate_CsharpEnum = `
    public enum {{.ConfigName}}{{.EnumName}}
    {
{{range .EnumElemList}}
	{{.EnumElemName}} = {{.EnumElemValue}},
{{end}}
    }
`

type genRuntimeCodeTool_Csharp struct {
}

func (self *genRuntimeCodeTool_Csharp) GenRuntimeCode(outputPath string, provision *ConfigDefine, enumInfo []*EnumDefine) error {
	enumContent := ""
	for _, enum := range enumInfo {
		enumContentElement, err := generateCode(codeTemplate_CsharpEnum, enum, false)
		if err != nil {
			return err
		}
		enumContent += enumContentElement
	}

	for _, field := range provision.FieldList {
		if ok, enumInfo := checkFieldIsInEnumWithName(field.Type); ok {
			field.Type = provision.ConfigName + enumInfo.Name
		} else {
			field.Type = self.convertToSelfType(field.Type)
		}
		if field.IsList {
			field.Type = "List<" + field.Type + ">"
		}
	}

	provision.EnumInfoTemplate = enumContent

	var content string
	var err error

	if provision.MapKeyType != "" {
		provision.MapKeyType = self.convertToSelfType(provision.MapKeyType)
		content, err = generateCode(codeTemplate_CsharpMap, provision, false)
		if err != nil {
			return err
		}
	} else {
		content, err = generateCode(codeTemplate_CsharpList, provision, false)
		if err != nil {
			return err
		}
	}
	common.EnsureFolder(outputPath + "/Csharp/")

	err = common.WriteFileByName(outputPath+"/Csharp/"+provision.ConfigName+".cs", []byte(content))

	return err
}
func (self *genRuntimeCodeTool_Csharp) Name() define.SupportLan {
	return define.SupportLan_Csharp
}

func (self *genRuntimeCodeTool_Csharp) convertToSelfType(fieldType string) string {
	switch fieldType {
	case "int32":
		return "int"
	case "int64":
		return "long"
	case "float32":
		return "float"
	case "float64":
		return "double"
	case "bool":
		return "bool"
	case "string":
		return "string"
	case "time":
		return "DateTime"
	case "color":
		return "Color"
	default:
		return "int"
	}
}
